<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Viewer</title>
    <script>
        // Domain verification - runs immediately
        (function() {
            const allowedDomains = [
                'https://customdemo.experience.avaya.com',
                'http://localhost',
                'http://127.0.0.1'
            ];

            function isAllowedDomain() {
                if (window.self === window.top) {
                    // Not in an iframe, allow
                    return true;
                }

                try {
                    const parentDomain = document.referrer;
                    return allowedDomains.some(domain => parentDomain.startsWith(domain));
                } catch (e) {
                    return false;
                }
            }

            if (!isAllowedDomain()) {
                window.top.location = window.self.location;
            }
        })();
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #controls {
            padding: 10px;
            background: #f0f0f0;
        }

        #serverControls {
            margin-bottom: 10px;
        }

        #viewer {
            flex: 1;
            position: relative;
            overflow-x: hidden;
            display: block;
            background-color: #222;
            width: 100%;
        }

        #browserCanvas {
            max-width: 100%;
            width: 100%;
            display: block;
            cursor: default;
        }

        /* Removed old #loadingOverlay styles */

        /* New Loading Container Styles */
        #loadingContainer {
            display: none; /* Hidden by default */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white; /* Changed to white */
            z-index: 10;
            overflow: hidden; /* Keep birds contained */
        }

        #loadingContent {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.8); /* Light semi-transparent background */
            padding: 5px 10px;
            border-radius: 5px;
            color: black; /* Changed text color to black */
            font-family: sans-serif;
            font-size: 14px;
            z-index: 11; /* Above birds */
        }

        #loadingLogo {
            width: 70px; /* Scaled down */
            height: 20px;
            margin-right: 10px;
        }

        #loadingText {
            display: flex;
            flex-direction: column;
        }

        #loadingUrl {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px; /* Limit URL width */
        }

        #loadingMessage {
            font-size: 12px;
        }

        /* Bird Animation CSS */
        .bird{
            background-image: url('https://s3-us-west-2.amazonaws.com/s.cdpn.io/174479/bird-cells-new.svg');
            /* filter: invert(34%) sepia(55%) saturate(427%) hue-rotate(141deg) brightness(93%) contrast(91%); */ /* Removed filter for white background */
            background-size: auto 100%;
            width: 88px;
            height: 125px;
            will-change: background-position;

            animation-name: fly-cycle;
            animation-timing-function: steps(10);
            animation-iteration-count: infinite;
        }

        .bird-one{
            animation-duration: 1s;
            animation-delay: -0.5s;
        }
        .bird-two{
            animation-duration: 0.9s; /* Corrected syntax */
            animation-delay: -0.75s; /* Corrected syntax */
        }
        .bird-three{
            animation-duration:1.25s;
            animation-delay: -0.25s;
        }
        .bird-four{
            animation-duration: 1.1s;
            animation-delay: -0.5s;
        }

        .bird-container {
            position: absolute;
            top: 10%;
            left: -10%; /* Start further left */
            transform: scale(0) translateX(-10vw);
            will-change: transform;

            animation-name: fly-right-one; /* Using one animation for simplicity, adjust if needed */
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            z-index: 9; /* Below loading text */
        }

        .bird-container-one{
            animation-duration: 15s;
            animation-delay: 0;
        }

        .bird-container-two{
            animation-duration: 16s;
            animation-delay: 1s;
        }

        .bird-container-three{
            animation-duration: 14.6s;
            animation-delay: 9.5s;
        }

        .bird-container-four {
            animation-duration: 16s;
            animation-delay: 10.25s;
        }

        @keyframes fly-cycle {
            100% {
                background-position: -900px 0;
            }
        }

        @keyframes fly-right-one {
            0% { transform: scale(0.3) translateX(-10vw) translateY(20vh); }
            10% { transform: translateY(18vh) translateX(10vw) scale(0.4); }
            20% { transform: translateY(10vh) translateX(30vw) scale(0.5); }
            30% { transform: translateY(24vh) translateX(50vw) scale(0.6); }
            40% { transform: translateY(12vh) translateX(70vw) scale(0.6); }
            50% { transform: translateY(20vh) translateX(90vw) scale(0.6); }
            60% { transform: translateY(15vh) translateX(110vw) scale(0.6); }
            100% { transform: translateY(15vh) translateX(110vw) scale(0.6); }
        }

        /* Removed fly-right-two as fly-right-one is used for all */

        .status-connected {
            color: green;
        }

        .status-disconnected {
            color: red;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>
    <div id="controls">
        <div id="serverControls">
            <input type="text" id="serverInput" placeholder="Server URL" value="http://localhost:8080">
            <button onclick="connectToServer()">Connect to Server</button>
            <span id="connectionStatus" class="status-disconnected">Disconnected</span>
        </div>
        <div>
            <input type="text" id="urlInput" placeholder="Enter URL" value="https://example.com">
            <button onclick="startSession()" id="loadButton" disabled>Load URL</button>
        </div>
    </div>
    <div id="viewer">
        <canvas id="browserCanvas"></canvas>
        <!-- New Loading Container -->
        <div id="loadingContainer">
            <div id="loadingContent">
                <img id="loadingLogo" src="images/avaya_logo.svg" alt="Avaya Logo">
                <div id="loadingText">
                    <span id="loadingUrl"></span>
                    <span id="loadingMessage">Loading...</span>
                </div>
            </div>
            <!-- Bird Animation -->
            <div class="bird-container bird-container-one">
                <div class="bird bird-one"></div>
            </div>
            <div class="bird-container bird-container-two">
                <div class="bird bird-two"></div>
            </div>
            <div class="bird-container bird-container-three">
                <div class="bird bird-three"></div>
            </div>
            <div class="bird-container bird-container-four">
                <div class="bird bird-four"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Security check on load
        document.addEventListener('DOMContentLoaded', () => {
            const allowedDomains = [
                'https://customdemo.experience.avaya.com',
                'http://localhost',
                'http://127.0.0.1',
                'https://localhost:3000'
            ];

            function checkDomainAccess() {
                if (window.self === window.top) {
                    return true; // Not in an iframe
                }

                try {
                    const parentOrigin = new URL(document.referrer).origin;
                    return allowedDomains.includes(parentOrigin);
                } catch (e) {
                    console.error('Domain access check failed:', e);
                    return false;
                }
            }

            if (!checkDomainAccess()) {
                document.body.innerHTML = '<h1>Access Denied</h1><p>This content cannot be displayed in an iframe from your domain.</p>';
                return;
            }
        });
    </script>
    <script>
        let socket = null;
        const canvas = document.getElementById('browserCanvas');
        const ctx = canvas.getContext('2d');
        // const loadingOverlay = document.getElementById('loadingOverlay'); // Removed reference to old overlay
        const connectionStatus = document.getElementById('connectionStatus');
        const loadButton = document.getElementById('loadButton');
        const controls = document.getElementById('controls');
        // New loading elements
        const loadingContainer = document.getElementById('loadingContainer');
        const loadingUrl = document.getElementById('loadingUrl');
        const loadingMessage = document.getElementById('loadingMessage');
        let progressInterval = null; // To manage the simulated progress

        // Parse URL parameters
        function getUrlParameters() {
            const params = new URLSearchParams(window.location.search);
            return {
                socketUrl: params.get('socket'),
                targetUrl: params.get('url')
            };
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            const params = getUrlParameters();
            if (params.socketUrl && params.targetUrl) {
                // Hide controls if we have URL parameters
                controls.classList.add('hidden');
                // Auto-connect to socket and load URL
                document.getElementById('serverInput').value = params.socketUrl;
                document.getElementById('urlInput').value = params.targetUrl;
                autoConnect(params.socketUrl, params.targetUrl);
            }
        });

        // Auto-connect function
        async function autoConnect(socketUrl, targetUrl) {
            console.log('autoConnect called with socketUrl:', socketUrl, 'and targetUrl:', targetUrl);
            // Normalize targetUrl immediately if provided via parameters
            if (targetUrl && !targetUrl.match(/^https?:\/\//i)) {
                targetUrl = 'https://' + targetUrl;
                console.log('Normalized targetUrl in autoConnect to:', targetUrl);
                // Update the input field as well for consistency, though it's hidden
                document.getElementById('urlInput').value = targetUrl;
            }
            try {
                await connectToServerAsync(socketUrl);
                // Wait a brief moment to ensure socket connection is stable
                setTimeout(() => {
                    if (socket && socket.connected) {
                        startSession(targetUrl);
                    }
                }, 500);
            } catch (error) {
                console.error('Auto-connect failed:', error);
                controls.classList.remove('hidden'); // Show controls if auto-connect fails
            }
        }

        // Modified connect function to return a promise
        function connectToServerAsync(serverUrl) {
            return new Promise((resolve, reject) => {
                if (socket) {
                    socket.disconnect();
                }

                try {
                    // Ensure secure connection from HTTPS pages
                    let secureServerUrl = serverUrl;
                    if (window.location.protocol === 'https:' && serverUrl.startsWith('http://')) {
                        secureServerUrl = serverUrl.replace('http://', 'https://');
                        console.log(`Attempting secure connection to: ${secureServerUrl}`);
                    } else if (window.location.protocol === 'https:' && !serverUrl.startsWith('https://')) {
                        // Handle cases where URL might not have a protocol or is relative (less likely for socket URLs)
                        // Assuming it should be https if the page is https
                        if (!serverUrl.includes('://')) {
                             // Basic check if it looks like a domain/IP without protocol
                             if (serverUrl.match(/^([a-zA-Z0-9.-]+)(:\d+)?(\/.*)?$/)) {
                                secureServerUrl = 'https://' + serverUrl;
                                console.log(`Assuming secure connection for relative/no-protocol URL: ${secureServerUrl}`);
                             }
                        }
                    }


                    socket = io(secureServerUrl, {
                        // Force WebSocket transport only
                        transports: ['websocket'],
                        // Disable automatic reconnection for this test
                        reconnection: false
                    });

                    setupSocketListeners(resolve, reject);
                    // Removed old overlay logic during connection attempt
                } catch (error) {
                    console.error('Connection error:', error);
                    updateConnectionStatus('Connection Error', false);
                    loadingContainer.style.display = 'none'; // Ensure new container is hidden on initial connection error
                    reject(error);
                }
            });
        }

        // Modified to support the original click-based connection
        function connectToServer() {
            const serverUrl = document.getElementById('serverInput').value;
            connectToServerAsync(serverUrl).catch(console.error);
        }

        function setupSocketListeners(resolve = null, reject = null) {
            socket.on('connect', () => {
                console.log('Connected to server');
                updateConnectionStatus('Connected', true);
                // Removed old overlay logic on connect
                loadButton.disabled = false;
                if (resolve) resolve();
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                updateConnectionStatus('Disconnected', false);
                loadButton.disabled = true;
            });

            socket.on('connect_error', (error) => {
                console.error('Connection error:', error);
                updateConnectionStatus('Connection Error', false);
                // Removed old overlay logic on connect error
                if (reject) reject(error);
            });

            // Keep all your existing socket listeners - Modified sessionStarting
            socket.on('sessionStarting', ({ url }) => {
                console.log(`Server is starting session for: ${url}`);
                // No longer using the old overlay here, handled in startSession()
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                canvas.style.width = '0px';
                canvas.style.height = '0px';
            });

            // Modified screenshot handler
            socket.on('screenshot', (base64Image) => {
                console.log('screenshot event received. Attempting to hide loading container.'); // Added log
                // Hide the new loading container when the first image arrives
                if (loadingContainer.style.display !== 'none') {
                    loadingContainer.style.display = 'none';
                    console.log('Loading container hidden.'); // Added log
                    if (progressInterval) {
                        clearInterval(progressInterval); // Stop progress simulation
                        progressInterval = null;
                    }
                } else {
                    console.log('Loading container was already hidden.'); // Added log
                }

                const image = new Image();
                image.onload = () => {
                    canvas.width = image.naturalWidth;
                    canvas.height = image.naturalHeight;
                    ctx.drawImage(image, 0, 0);
                    resizeCanvas();
                };
                image.src = `data:image/jpeg;base64,${base64Image}`;
            });

            // Modified error handler
            socket.on('error', (error) => {
                console.error('Server error:', error);
                loadingUrl.textContent = 'Error';
                loadingMessage.textContent = `Error: ${error}`;
                loadingContainer.style.display = 'flex'; // Keep loading visible on error
                if (progressInterval) {
                    clearInterval(progressInterval); // Stop progress simulation
                    progressInterval = null;
                }
            });

            socket.on('reconnect', (attemptNumber) => {
                console.log('Reconnected after', attemptNumber, 'attempts');
                updateConnectionStatus('Connected', true);
                // Removed old overlay logic on reconnect
            });
        }

        function updateConnectionStatus(status, isConnected) {
            connectionStatus.textContent = status;
            connectionStatus.className = isConnected ? 'status-connected' : 'status-disconnected';
        }

        function startSession(urlOverride = null) {
            if (!socket || !socket.connected) {
                alert('Please connect to a server first');
                return;
            }

            let url = urlOverride || document.getElementById('urlInput').value;
            console.log('startSession called with initial URL:', url);

            // Normalize URL: Prepend https:// if no protocol is present
            if (url && !url.match(/^https?:\/\//i)) {
                url = 'https://' + url;
                console.log('Normalized URL to:', url);
            }

            // Show the new loading container and set initial state
            loadingUrl.textContent = url;
            loadingMessage.textContent = 'Loading... 0%';
            console.log('Attempting to display loading container...'); // Added log
            loadingContainer.style.display = 'flex';
            console.log('Loading container display set to flex.'); // Added log

            // Clear previous canvas content
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.style.width = '0px';
            canvas.style.height = '0px';

            // Clear any existing progress simulation
            if (progressInterval) {
                clearInterval(progressInterval);
            }

            // Simulate loading progress (adjust timing as needed)
            let progress = 0;
            const estimatedLoadTime = 5000; // 5 seconds estimate
            const intervalTime = 200; // Update every 200ms
            progressInterval = setInterval(() => {
                progress += (intervalTime / estimatedLoadTime) * 100;
                if (progress >= 99) {
                    progress = 99; // Don't quite hit 100%
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
                loadingMessage.textContent = `Loading... ${Math.round(progress)}%`;
            }, intervalTime);

            // Final URL normalization check right before emitting
            if (url && !url.match(/^https?:\/\//i)) {
                console.log(`Re-normalizing URL from "${url}" just before emit.`);
                url = 'https://' + url;
                console.log(`Final URL for emit: "${url}"`);
            }

            socket.emit('startSession', { url });
        }

        // Keep all your existing event listeners
        canvas.addEventListener('wheel', (e) => {
            if (socket && socket.connected) {
                e.preventDefault();
                socket.emit('scroll', { deltaY: e.deltaY });
            }
        });

        // Keep your existing mouse event listeners
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        canvas.addEventListener('mousedown', (e) => {
            if (socket && socket.connected) {
                isDragging = false;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / canvas.style.width.replace('px', '');
                const scaleY = canvas.height / canvas.style.height.replace('px', '');
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                socket.emit('mousedown', { x, y });
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (socket && socket.connected) {
                if (Math.abs(e.clientX - dragStartX) > 5 || Math.abs(e.clientY - dragStartY) > 5) {
                    isDragging = true;
                }
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / canvas.style.width.replace('px', '');
                const scaleY = canvas.height / canvas.style.height.replace('px', '');
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                socket.emit('mousemove', { x, y, isDragging });
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (socket && socket.connected) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / canvas.style.width.replace('px', '');
                const scaleY = canvas.height / canvas.style.height.replace('px', '');
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                if (!isDragging) {
                    socket.emit('click', { x, y });
                }
                
                socket.emit('mouseup', { x, y });
                isDragging = false;
            }
        });

        function resizeCanvas() {
            if (!canvas.width || !canvas.height) return;

            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const canvasRatio = canvas.width / canvas.height;

            let displayWidth = containerWidth;
            let displayHeight = displayWidth / canvasRatio;

            if (displayHeight > containerHeight) {
                document.getElementById('viewer').style.overflowY = 'auto';
            } else {
                document.getElementById('viewer').style.overflowY = 'hidden';
            }

            canvas.style.width = `${displayWidth}px`;
            canvas.style.height = `${displayHeight}px`;
        }

        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
